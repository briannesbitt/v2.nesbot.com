@*This blog is now running on Play 2.0 BETA*@

@import helpers.Html._

<p>Yes my blog is <b>LIVE</b> and yes this now running on <b>BETA</b> version of the Play framework 2.0.</p>

<h2>Are you crazy?</h2>

<p>The feeling I get from the release is that it's a beta release in terms of framework features but not really from a stability/performance standpoint.  The team behind Play has gathered some great experience from Play 1.X so this hardly thier first attempt.  I haven't experienced any show stoppers during my use (granted short lived) or seen any large issues on the google group besides "when is this going to get implemented".  The reality is that this is my personal blog.  If it instantaneously self combusts for a couple of minutes/hours/days we all shall live ... plus it makes for a great story!</p>

<h2>Some more reasoning... however crazy!</h2>

<p>The framework is built on top of <a href="http://www.jboss.org/netty">netty</a> which has been around for years.  It doesn't automatically give you a home-run (read web framework out of the box) but it does give you an easy stand up double (stable networking layer and http implementation).</p>

<p>Another large portion of the framework is the template engine.  Play 2.0 includes a powerful Scala-based template engine. The template engine's design was inspired by ASP.NET Razor.  The template engine was first introduced in the Scala version of Play 0.9.1, about 6 months ago.  Sure its integrated into a different framework now, but I suspect it was most likely easier this time around since the core is now developed in Scala while before it was added as a plugin on top of the core Java framework.  This of course doesn't make it bullet proof but its further ahead than just being developed brand new for 2.0.</p>

<p>I am not really trying to convince anyone to start using this version. I just know for my personal blog I am ok with <a href="TODO youtube link">living on the edge</a>.  From my current understanding as mentioned by the project lead they expect a final version <i>"Early next year"</i> with a <i>"first release candidate end of January"</i>. If history is a good indicator (which I think it is) and with the Typesafe announcement (+possible dev resources) I am sure the development will move along as smoothly as can be expected</p>

<p>How my blog was setup on Play 1.2.X</p>

<p>
Used to keep posts in YYYY-mm-dd-slug-slug-slug.html but moved to pYYYYmmdd_slug_slug_slug.scala.html
and do a replace("_", "-") on the slug.
</p>

<p>
Then I had to try and render them via the Scala template engine.  With groovy you could dynamically include a template.
Now the templates are all static and typesafe so my method of dynamically including a file based on a string was going to take some work.
I ended up doing this with reflection.  The template is just a Scala class in the classpath so I can find the class and invoke the render method.
</p>


<h2>Blank lines in rendered HTML</h2>

<p>
When I was getting the /rss feed working I kept getting the open/save option in Firefox rather than the nice rss page that it usually shows.  It turns out that there were some blank lines at the top of the rendered xml.  Tweaking the Scala template a bit I determined:
<ul>
<li>If you just have a simple no args template file then there are no blank lines.</li>
<li>If you specify arguments at the top of the template "@@(s : String)" then you will get 1 blank line.</li>
<li>If you start calling layouts... more blank lines.</li>
<li>@@import lines don't generate a blank line.</li>
</ul>
</p>

<p>For most pages this does not matter. If you generate an RSS page though, blank lines at the top do matter - so it seems.  At first I used my trusty hammer (you know the tool that can solve everything!) and hacked up the controller.</p>

<pre class="brush: java">
public static Result rss()
{
   response().setContentType("application/rss+xml");
   String body = rss.render(Post.findAll()).body();

   /* HACK TO REMOVE FIRST BLANK LINE */
   /*char c = body.charAt(0);
   while (c == '\r' || c == '\n')
   {
      body = body.substring(1);
      c = body.charAt(0);
   }
   /* HACK TO REMOVE FIRST BLANK LINE */

   return ok(body);
}
</pre>

<p>This worked just fine, but of course wasn't ideal.  I did learn more about the template system which was a win.  In the end I figured out that if you put your content up on the first line after the arguments it prevents the blank line, which even though its a minus for readability, its not that bad and a better solution than the hack above.</p>

<pre class="brush: java">
@@(arg : String)<?xml version="1.0" encoding="UTF-8" ?>
</pre>


Working on a post I can create the file using an "a_" prefix which will do 3 things for me.  It will get it into github so I won't lose anything I write if its not done in one sitting.  I can actually track my changes on each post if I ever need to see the change history.  It will get sorted to the top in a directory listing so I can always see which post I am currently working on.








==============================


Used to keep posts in YYYY-mm-dd-slug-slug-slug.html but moved to pYYYYmmdd_slug_slug_slug.scala.html
and do a replace("_", "-") on the slug.

Then I had to try and render them via the scala template engine.  With groovy you could dynamically include a template.
Now the templates are all static and typesafe so my method of dynamically including a file based on a string was going to take some work.
I ended up doing this with reflection.  The template is just a scala class in the classpath so I can find the class and invoke the render method.



I didn't see anything in the wiki yet about this... I suspect its on the *long* TODO list :-)

There is a helper play.Configuration.getSub() to get all values in a sub-configuration so I am thinking this will get integrated into the getString() methods to see if there is a mode.value or just a value defined.

In the mean time I have implemented it this way (removed the synchronization for simplicity here):
public class Config
{
   private static Configuration config;

   private static Configuration config()
   {
      if (config != null)
      {
         return config;
      }
      return config = Play.isDev(Play.current()) ? Configuration.root().getSub("dev") : Configuration.root().getSub("prod");
   }

   public static String googleAnalyticsTracker()
   {
      return config().getString("gatracker");
   }
}

So now you can just call Config.googleAnalyticsTracker() and you get the environment specific version.

In any template:
   @@helpers.Config.googleAnalyticsTracker

or:

@@import helpers.Config._

@@googleAnalyticsTracker


Then of course according to what you are getting, if it isn't env specific:
public static String appName()
{
   return Play.Configuration.root().getString("application.name");
}





Extensions are gone.  Now you write any java class and statically import it into the template.
Things like nl2br and urlencode can be done like:

Its all type checked at compile time so you can overload methods etc.






core 17 860  8 GB ram, SSD

ab -n 10000 -c 6 http://127.0.0.1:9001/

2.8k requests/sec
99% were done in 4 ms

4k requests/sec
99% were done in 3 ms

ab -n 10000 -c 6 http://127.0.0.1:9000/2011/9/20/cobertura-module-tricks-with-the-play-framework

1k
99% were done in 7 ms

1.6k
99% were done in 6 ms



